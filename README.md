# Monorepo with Lerna

## Steps

### Init lerna on the repo

```
$ npx lerna init
```

### Modify `lerna.json` and `package.json` to use Workspaces feature

```
// package.json
{
  "name": "root",
  "private": true,
  "workspaces": ["packages/*"],
  "devDependencies": {
    "lerna": "^3.22.1"
  }
}
```

```
// lerna.json
{
  "packages": ["packages/*"],
  "npmClient": "yarn",
  "useWorkspaces": true,
  "version": "independent"
}
```

Weâ€™ll use independent versioning so we can properly enforce semver for each
package.

### Install Babel dependencies

Using `-w` instructs Yarn to install the given dependencies for the entire
workspace. These dependencies are usually shared between all packages.

```
$ yarn add --dev -W @babel/cli @babel/core @babel/preset-react @babel/preset-env babel-core@7.0.0-bridge.0 babel-loader babel-plugin-styled-components webpack
```

And create a `babel.config.js` file on the root. `.babelrc` or `.babelrc.json`
doesn't work.

```
{
  "presets": ["@babel/preset-env", "@babel/preset-react"],
  "plugins": ["babel-plugin-styled-components"]
}
```

And add a script on `package.json` to execute Babel

```
"scripts": {
    "build": "lerna exec --parallel -- babel --root-mode upward src -d lib --ignore **/*.stories.js,**/*.spec.js"
}
```

lerna exec will take any command and run it over all of the different packages.
This command instructs Babel to run in parallel over every package, pulling from
the /src folder and compiling into the /lib folder.

Using `--root-mode upward` is the special sauce to using Yarn workspaces. This
tells Babel the `node_modules` are located in the root instead of nested inside
each of the individual packages. This prevents each package from having the same
`node_modules` and extracts them up to the root. Weâ€™ll be utilizing a similar
approach for testing later.

### React

Create some packages to consume. In this example we'll be using React and Styled
Components.

```
$ yarn add --dev -W react react-dom styled-components
```

The structure of each package will be:

```
|- packages/
|---- button/
|-------- package.json
|-------- src/ // (our source files)
|-------------- Button.js
|-------------- Button.spec.js
|-------------- Button.stories.js
|-------- lib // (generated by babel)
```

And the `package.json` for each 'component' will be:

```
{
  "name": "button",
  "version": "1.0.0",
  "main": "lib/index.js",
  "module": "src/index.js",
  "dependencies": {
    "react": "latest",
    "react-dom": "latest",
    "styled-components": "latest"
  },
  "peerDependencies": {
    "react": "^16.0.0",
    "react-dom": "^16.0.0",
    "styled-components": "^5.0.0"
  }
}
```

Listing the `peerDependencies` helps ensure consumers are including the correct
packages.

To link our root dependencies to our newly created package we need to create a
script inside our root `package.json`

```
"scripts": {
  "bootstrap": "lerna bootstrap --use-workspaces"
}
```

Once our component is coded, we should be able to run `yarn build` and see a
`/lib` folder create for our new package.

### Storybook

```
$ yarn add --dev -W @storybook/react @storybook/addon-docs @storybook/preset-create-react-app
```

Configure Storybook:

```
// .storybook/main.js
module.exports = {
  stories: ['../packages/**/*.stories.js'],
  addons: ['@storybook/addon-docs']
};
```

Create a script inside our root `package.json` to start storybook:

```
"scripts": {
  "dev": "start-storybook -p 6006"
}
```

### Testing

letâ€™s set up our testing environment and create a simple test for our button.
Weâ€™ll utilize Jest for unit testing. It will automatically pick up any files
ending with `.spec.js` or `.test.js`.

```
$ yarn add --dev -W jest jest-styled-components babel-jest react-test-renderer jest-resolve jest-haste-map
```

Configure Jest:

```
// jest.config.js
module.exports = {
  cacheDirectory: '.jest-cache',
  coverageDirectory: '.jest-coverage',
  coveragePathIgnorePatterns: ['<rootDir>/packages/(?:.+?)/lib/'],
  coverageReporters: ['html', 'text'],
  coverageThreshold: {
    global: {
      branches: 100,
      functions: 100,
      lines: 100,
      statements: 100
    }
  },
  testPathIgnorePatterns: ['<rootDir>/packages/(?:.+?)/lib/']
};
```

Add the following scripts to our root `package.json`.

```
"scripts": {
  "coverage": "jest --coverage",
  "unit": "jest"
}
```

### Releasing

> ðŸ‘€ You need to commit and push to your repository before releasing. If you
> havenâ€™t done that, do it now.

We can use `npx lerna changed` to see which packages have changed. You can also
use `npx lerna diff` to see specifically what lines changed.

Letâ€™s run `npx lerna version` to simulate releasing them.

```
$ npx lerna version
lerna notice cli v3.20.2
lerna info versioning independent
lerna info Assuming all packages changed
? Select a new version for button (currently 1.0.0)
? Select a new version for button (currently 1.0.0)

Changes:
 -  button: 1.0.0 => 1.0.1
 -  input: 1.0.0 => 1.0.1

? Are you sure you want to create these releases? Yes
lerna info execute Skipping GitHub releases
lerna info git Pushing tags...
lerna success version finished
```

The tags have been pushed to GitHub. If we wanted to release our packages to
NPM, we would use `npx lerna publish` instead.

### ðŸš§ TODOs

- Linting and formating with:
  - [ESLint](https://eslint.org/)
  - [Stylelint](https://github.com/stylelint/stylelint)
  - [Prettier](https://prettier.io/)
- Pre-commit hooks with [Husky](https://github.com/typicode/husky)
- Automate [semver](https://semver.org/) on releases using
  [conventional commits](https://www.conventionalcommits.org/)
- Create a theme package to shre across all other packages.
